---
layout: post
title: Introducing Ruby to ActionScripters
author: Luke Bayes
post_image_flickr: http://www.flickr.com/photos/greencolander/2895452690
post_image_author_link: http://www.flickr.com/photos/greencolander/
post_image_author_name: Greencolander
post_image_license: http://creativecommons.org/licenses/by/2.0/
post_image_local: /images/2895452690_911065b1f3_z.jpg
post_image_title: Ruby Pomegranate Seeds
---

h1. {{ page.title }}

{{ page.date | date_to_string }} - {{ page.author }}

<div id="quotes">
  <blockquote>Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.</blockquote>
  <div class="attribution"> "Ruby Website":http://ruby-lang.org </div>
</div>

This means that Ruby has opinions, and many of Ruby's opinions are exactly inverted from what you may have grown to love in ActionScript. There was a time when this made me uncomfortable, and I'm sure it will make some of you uncomfortable. Well, not _you_ of course, but maybe someone you know...

If you're perfectly content with massive, repetitive build scripts, manually keeping build environments consistent, and your current workflow, please stop reading now. Sprouts is probably *not* for you. 

For the rest of you that aren't familiar with Ruby and the build system Rake, I'm about to do my very best to provide a gentle introduction, and when we're done, I hope you'll be comfortable at least reading, and hopefully, editing Rakefiles with confidence.

<span class="attribution">
<image class="bordered" src="{{ page.post_image_local }}" title="{{ page.post_image_title}}" />
<a href="{{ page.post_image_flickr }}">{{ page.post_image_title }}</a> courtesy of <a href="{{ page.post_image_author_link }}">{{ page.post_image_author_name }}</a> and the <a href="{{ page.post_image_license }}">Creative Commons</a> license.
</span>

h1. Quack like a what?

Ruby is a dynamic language, which means that a variable can be essentially any concrete data type. The important thing is that an object define the methods and attributes that its clients attempt to access. This paradigm is often referred to as <a target="_blank" href="http://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a>.

When it's unfamiliar, Ruby syntax has a few rules that can trip you up, so I'll kick this off by reviewing some key features of the language.

I'm going to do my best to give you the basics of Ruby here, but you should definitely make time to read <a target="_blank" href="http://mislav.uniqpath.com/poignant-guide/">Why's Poignant Guide to Ruby</a>.  

h2. Trying Ruby

If you have installed Ruby and gotten it into your system path, you can kick off a <a target="_blank" href="http://en.wikipedia.org/wiki/Read-eval-print_loop">Read Eval Print Loop (REPL)</a> by typing:

{% highlight bash %}
irb
{% endhighlight %}

_(Type 'quit' and hit enter to leave the REPL)_

The @puts@ method will send a String value to stdout and you can think of this like ActionScript's @trace@ method.

{% highlight ruby %}
puts "Hello World"
{% endhighlight %}

Try running irb and then @puts@ some messages now.

When using irb, you can do the following to try out Sprout features.

{% highlight ruby %}
require 'rubygems'
require 'sprout'

# do something here...
{% endhighlight %}

h2. Strings

There are a handful of different ways to declare Strings in Ruby, but the main thing I'd like to highlight here is the difference between single quotes and double quotes.

A String that is defined within single quotes will contain literally whatever is defined within the quotes. This means that backslashes will not be rendered as escape sequences, they will literally just be backslashes.

Single quotes require less overhead from the Ruby interpreter and are therefore preferred. I usually use single quotes wherever I don't need an evaluated expression or escape sequence.

{% highlight ruby %}
puts 'Hello World'
{% endhighlight %}

A String that is defined within double quotes will be interpreted for embedded Ruby expressions and escape sequences will be resolved so that they are replaced with the character literal that they represent.

{% highlight ruby %}
suffix = "World!\n"
str = "Hello #{suffix}"
{% endhighlight %}

If you're coming from ActionScript, you'll probably be tempted to concatenate Strings with expressions like:

{% highlight ruby %}
a = 'aaa'
b = 'bbb'
puts 'a: ' + a + ' b: ' + b
{% endhighlight %}

While this will usually work, it will explode if the expression values are nil. The preferred way to assemble Strings and expression values (especially for debugging), is to use double quotes and Ruby expression syntax like:

{% highlight ruby %}
puts "a: #{a} b: #{b}"
{% endhighlight %}

This will insert an empty String for values that are nil.

h2. Symbols

Ruby has an interesting primitive called a @Symbol@. Symbols are not Strings, but are often used in places where a String might also suffice. There are some differences between Symbols and Strings and the first one is that Symbols are more memory efficient than Strings. The key difference (for me at least) is that Symbols have rules about what characters are acceptable that don't apply to String values. The rules for what can and can't be used in a Symbol name are essentially the same rules for what can and can't be used for a Ruby method name. You can transform a String to a Symbol with the @to_sym@ method, and you can transform a Symbol to a String with the @to_s@ method. 

A Symbol is defined (or referenced) in Ruby with a leading colon as follows:

{% highlight ruby %}
name = :beaker
{% endhighlight %}

Symbols are most often used in Ruby as Hash keys, when referring to methods, and wherever a descriptive name is desirable, but all the functionality of a String is not required.

Symbols are a tricky part of Ruby and it's important when working with Rake files to understand when a Symbol is appropriate and when it is not. In Rake, a Symbol is often used for a Rake task name, _unless_ that task refers to a file, then a String must be used. This is because Symbols cannot include slashes, dots or other important components of a File name.

<a target="_blank" target="http://glu.ttono.us/articles/2005/08/19/understanding-ruby-symbols">More information on Symbols</a>

h2. Parentheses

The parentheses that surround parameters in a Ruby method declaration (and method calls) are _optional_, and by convention, are only used when they are required for the parser to work properly.

This does take some time to get used to, but it leads to some interesting improvements in readability. Generally, when I find myself adding parentheses to a statement, this is a (very mild) "smell":http://martinfowler.com/bliki/CodeSmell.html that I might be doing too much in one line.

Following are some examples to help you understand this issue.

This method in ActionScript:

{% highlight javascript %}
public function foo(a:String, b:String):void {
  trace("a: " + a + " b: " + b);
}
{% endhighlight %}

Would be defined like this in Ruby:

{% highlight ruby %}
def foo a, b
  puts "a #{a}, b #{b}"
end
{% endhighlight %}

But may also be written like this:

{% highlight ruby %}
def foo(a, b)
  puts "a #{a}, b #{b}"
end
{% endhighlight %}

Additionally, to call that method in ActionScript you might:

{% highlight ruby %}
foo("bar", "baz");
{% endhighlight %}

But in Ruby:

{% highlight ruby %}
foo "bar", "baz"
{% endhighlight %}

Of course, the following is also valid Ruby:

{% highlight ruby %}
foo("bar", "baz")
{% endhighlight %}

You may be wondering, "When _should_ I add the parens?" at this point. Here is a reasonable example of an expression that needs parens:

{% highlight ruby %}
assert foo("bar", "baz")
{% endhighlight %}

This expression is calling the imaginary @foo@ method, sending it two arguments, @bar@ and @baz@, then it's sending the return value of that method call to the @assert@ method. 

Even though the interpreter can figure out what's going on here, it's much more readable to parenthesize nested expressions like this.

h2. Return values

You should also know that Ruby methods always return a value, whether you use the @return@ keyword or not. The last expression that is evaluated within a Ruby method is what is returned. This can of course, be nil.

h2. Hash Rockets

Ruby Hashes are _(<a target="_blank" href="http://blog.peepcode.com/tutorials/2011/rip-ruby-hash-rocket-syntax">historically</a>)_ delimited by a "Hash Rocket", this is an equal sign, followed by a greater than sign, like:

{% highlight ruby %}
=>
{% endhighlight %}

To show what I mean, the following ActionScript Hash:

{% highlight javascript %}
var hash:Object = { a: 'a', b: 'b', c: 'c' };
{% endhighlight %}

Could be written in Ruby like this:

{% highlight ruby %}
hash = { :a => 'a', :b => 'b', :c => 'c' }
{% endhighlight %}

Even thought the Hash Rocket is no longer required in Ruby 1.9.x, Sprouts is still using it for the time being. We'll likely update to the new syntax at some point in the future.

h2. Hash Brackets

You should also note that, like parentheses on methods, curly brackets around Hashes are optional, so the previous Hash would normally be declared like:

{% highlight ruby %}
hash = :a => 'a', :b => 'b', :c => 'c'
{% endhighlight %}

Notice how the Ruby Hash prefixes the Hash keys with a colon. This indicates that we're using Symbols as keys.

h1. Rake

Rake is the library for creating and running build scripts using Ruby. I'm going to do my best to introduce some of the most basic features here, but you should definitely stop now and read <a target="_blank" href="http://martinfowler.com/articles/rake.html">Martin Fowler's seminal Rake article</a> on the subject.

h2. Tasks

Rake tasks are exposed in a Rake file as a simple Ruby method. You can create a new Rake task by calling the @task@ method and providing a task name as follows:

{% highlight ruby %}
task :my_task
{% endhighlight %}

This task isn't very exciting and won't do much at all when invoked. Before we get too deep here, I'd like to talk about that name argument. That argument can be a Symbol a String or a Hash, let's dig into when and why it might be each of these.

h3. Symbol Names

Rake tasks that don't directly result in the creation of a file on disk are usually named with Symbols. If you *can* name your task with a Symbol, you usually should.

{% highlight ruby %}
task :my_task
{% endhighlight %}

h3. String Names

Rake file tasks are named with a String. This is because the rules for Symbols cannot accomodate the requirements of file names. Rake tasks that need to be named with special characters for whatever reason are also named with Strings.

{% highlight ruby %}
file 'bin/SomeFile.xml'
{% endhighlight %}

h3. Hash Names

Rake tasks can be declared with a Hash if they depend on other tasks. The idea here is that the Hash has a single key/value pair, and the key is either a String or Symbol that is the name of the current task, and the value is a String, a Symbol or an Array (of Strings and/or Symbols) and defines which tasks must be invoked *before* this one. 

If that doesn't make sense, please read it a few more times. Understanding this complexity is really the crux of understanding Rake and being able to edit your Sprout Rake files.

Let's dig into a few examples.

The following is a very simple Rake task that depends on another very simple Rake task:

{% highlight ruby %}
task :my_task => :other_task
{% endhighlight %}

And here is one that depends on two other simple tasks:

{% highlight ruby %}
task :my_task => [:first_other_task, :second_other_task]
{% endhighlight %}

Noice how the hash rocket delimits the difference between the task name and it's value. Notice how we added the square brackets around the Array.

h2. Conclusion

This brings us to the end of the "{{ page.title }}" post. If you find anything here in error, <a target="_blank" href="http://groups.google.com/group/projectsprouts">please let us know</a>, or better yet - <a target="_blank" href="https://github.com/lukebayes/project-sprouts/blob/gh-pages/_source/_posts">fork</a>, fix and send a pull request.

